# -*- coding: utf-8 -*-
"""ode_solver_benchmark.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gyIF1PDHFPb1HaI1zmvhonzV3E1AXj4t
"""

import zipfile
import os

with zipfile.ZipFile("/content/GPUPy.zip", 'r') as zip_ref:
    zip_ref.extractall("/content/")

os.listdir("/content/")

import sys
sys.path.append("/content")

import numpy as np
import cupy as cp
import time
import matplotlib.pyplot as plt
from GPUPy.src.numerical_methods.ode_solver import odeint_wrapper

def benchmark_ode_solver():
    # Test problem: Stiff ODE system (Robertson problem)
    def robertson(y, t):
        xp = cp.get_array_module(y)  # Get the correct module (numpy or cupy)
        k1 = 0.04
        k2 = 3e7
        k3 = 1e4
        x, y_val, z = y
        dxdt = -k1*x + k3*y_val*z
        dydt = k1*x - k2*y_val*y_val - k3*y_val*z
        dzdt = k2*y_val*y_val
        return xp.array([dxdt, dydt, dzdt])

    # Jacobian for the Robertson problem
    def robertson_jac(y, t):
        xp = cp.get_array_module(y)  # Get the correct module (numpy or cupy)
        k1 = 0.04
        k2 = 3e7
        k3 = 1e4
        x, y_val, z = y
        J = xp.zeros((3, 3))
        J[0,0] = -k1
        J[0,1] = k3*z
        J[0,2] = k3*y_val
        J[1,0] = k1
        J[1,1] = -2*k2*y_val - k3*z
        J[1,2] = -k3*y_val
        J[2,1] = 2*k2*y_val
        return J

    # Scale up the problem by duplicating the system
    def create_large_system(n_copies=1000):
        def large_system(y, t):
            xp = cp.get_array_module(y)
            result = xp.zeros_like(y)
            for i in range(0, len(y), 3):
                y_part = y[i:i+3]
                result[i:i+3] = robertson(y_part, t)
            return result

        def large_jac(y, t):
            xp = cp.get_array_module(y)
            n = len(y)
            J = xp.zeros((n, n))
            for i in range(0, n, 3):
                y_part = y[i:i+3]
                J[i:i+3, i:i+3] = robertson_jac(y_part, t)
            return J

        return large_system, large_jac

    # Benchmark parameters
    n_copies_list = [1, 10, 100, 1000, 5000]  # Problem sizes to test
    t_span = np.linspace(0, 1e5, 100)  # Time points
    methods = ['BDF', 'RK45']

    # Results storage
    results = {method: {'cpu': [], 'gpu': [], 'speedup': []} for method in methods}

    # Run benchmarks
    for n_copies in n_copies_list:
        print(f"\nBenchmarking with {n_copies} copies of the system ({3*n_copies} equations)")

        # Create the large system
        func, jac = create_large_system(n_copies)
        y0 = np.tile([1.0, 0.0, 0.0], n_copies)  # Initial condition

        for method in methods:
            print(f"\nMethod: {method}")

            # CPU benchmark
            start = time.time()
            _ = odeint_wrapper(func, y0, t_span, use_gpu=False,
                             method=method, jacobian=jac if method=='BDF' else None)
            cpu_time = time.time() - start
            results[method]['cpu'].append(cpu_time)

            # GPU benchmark
            start = time.time()
            _ = odeint_wrapper(func, y0, t_span, use_gpu=True,
                             method=method, jacobian=jac if method=='BDF' else None)
            gpu_time = time.time() - start
            results[method]['gpu'].append(gpu_time)

            speedup = cpu_time / gpu_time
            results[method]['speedup'].append(speedup)

            print(f"CPU time: {cpu_time:.3f} s, GPU time: {gpu_time:.3f} s, Speedup: {speedup:.1f}x")

    # Plot results
    plt.figure(figsize=(12, 6))

    for i, method in enumerate(methods):
        plt.subplot(1, 2, i+1)
        plt.loglog(n_copies_list, results[method]['cpu'], 'o-', label='CPU')
        plt.loglog(n_copies_list, results[method]['gpu'], 's-', label='GPU')
        plt.title(f'{method} Method Performance')
        plt.xlabel('Number of system copies')
        plt.ylabel('Execution time (s)')
        plt.legend()
        plt.grid(True)

        # Add speedup annotations
        for j, n in enumerate(n_copies_list):
            plt.annotate(f'{results[method]["speedup"][j]:.1f}x',
                        (n, results[method]['gpu'][j]),
                        textcoords="offset points", xytext=(0,10), ha='center')

    plt.tight_layout()
    plt.savefig('ode_solver_benchmark.png')
    plt.show()

    return results

if __name__ == '__main__':
    benchmark_results = benchmark_ode_solver()

